package 정렬;

import java.util.Scanner;

public class 삽입정렬 {

	/**
	 * 
	 * [ 설명 ]
	 * 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
	 * 시간복잡도 O(n제곱)으로 느린 편이지만 구현하기가 쉽다.
	 * 
	 * 1. 현재 index에 있는 데이터 값을 선택한다.
	 * 2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
	 * 3. 삽입 위치부터 index에 있는 위치까지 shift연산을 수행한다.
	 * 4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
	 * 5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이타가 없을 때까지 반복한다.
	 * 
	 * 
	 * [ 슈드코딩 ]
	 * 
	 * N: 입력받을 배열의 길이
	 * A: N크기를 가진 배열
	 * 
	 * for(N만큼 반복){
	 * 		A데이터 입력 받기
	 * }
	 * 
	 * for(1~N번쨰 요소 꺼내기) {
	 * 		j 선언, i앞의 요소들과 i번째 요소를 비교하기 위한 용도
	 * 		temp 선언, A[i] 할당
	 * 
	 * 		for(j에 i 할당; j가 0보다 크고, temp(위에서 선택된 요소)가 그 앞의 요소들보다 큰지 검사; j--(앞으로 진행) ){
	 * 			i앞의 요소들을 한칸씩 뒤로 밀기
	 * 		}	
	 * 
	 * 		 temp를 j번째에 할당(for문 마지막에 j--으로 인해, 뒤로 미뤄진 요소 바로 앞에 할당됨)
	 * }
	 * 
	 * for(N번 반복){
	 * 		정렬된 A배열 출력하기
	 * }
	 * 
	 * 
	 * **/
	public static void main(String[] args) {
	
		Scanner sc = new Scanner(System.in);
		
		int N 	= sc.nextInt();		// 배열의 길이
		int[] A = new int[N];		// 정렬할 배열
		
		// 입력받은 요소 배열에 넣기
		for(int i=0; i<N; i++) {
			A[i] = sc.nextInt();
		}
		
		// 1번째 요소부터 정렬할 요소를 선택함
		for(int i=1; i<N; i++) {
			int j;
			int temp = A[i];	// 선택된 요소를 temp에 할당
			
			// i번째 요소(temp)를 알맞은 위치에 삽입하는 부분		// 자신보다 작거나 같은 요소 뒤에 삽입됨
			for(j=i;
				j>0					// j가 0보다 크고
				&& A[j-1] > temp;	// j번쨰 요소가 i번째 요소보다 클 때 
				j--) {
				
				A[j] = A[j-1];	// 선택된 요소 앞의 것들을 위로 하나씩 밀기 
			}
			
			A[j] = temp;		// i번째 요소를 알맞은 자리에 배치한다.(위 for문의 조건: j가 0보다 크고, j번쨰 요소가 i번째 요소보다 클 때 )
		}
			
		for(int i=0; i<N; i++) {
			System.out.print(A[i] + "  ");
		}	

	}

}
